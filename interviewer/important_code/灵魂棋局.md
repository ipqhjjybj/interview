class Solution {
public:
    int visit[200][200];
    int directions[4][2] = {
        {0, 1}, // 向右走
        {1, 0}, // 向下走
        {0, -1}, // 向左走
        {-1, 0}  // 向上走
    };
    int n, m;
    vector<int> ans;
    void dfs(vector<vector<int>>& matrix, int point_x, int point_y, int direction){
        printf("point_x:%d, point_y:%d direction:%d\n", point_x, point_y, direction);
        if(!visit[point_x][point_y]){
            printf("push !visit:%d %d\n", point_x, point_y);
            ans.push_back(matrix[point_x-1][point_y-1]);
            if(ans.size() == n * m){
                return;
            }
            visit[point_x][point_y] = 1;
            point_x = point_x + directions[direction][0];
            point_y = point_y + directions[direction][1];
            dfs(matrix, point_x, point_y, direction);
        }else{
            int houtui_x = directions[direction][0] * -1;
            int houtui_y = directions[direction][1] * -1;
            direction = (direction + 1) % 4;
            point_x = point_x + directions[direction][0] + houtui_x;
            point_y = point_y + directions[direction][1] + houtui_y;
            dfs(matrix, point_x, point_y, direction);
        }
    }
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        ans.clear();
        memset(visit, 0, sizeof(visit));
        int start_x = 1, start_y = 1;
        n = matrix.size();
        m = matrix[0].size();
        printf("n=%d m=%d\n", n, m);
        for(int i = 1;i <= m;i++){
            visit[0][i] = 1;
            visit[n+1][i] = 1;
        }
        for(int i = 1;i <= n;i++){
            visit[i][0] = 1;
            visit[i][m+1] = 1;
        }
        dfs(matrix, 1, 1, 0);
        return ans;
    }
};